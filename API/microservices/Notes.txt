 Scaling
    - Horizontal scaling refers to adding additional nodes/computer
        - Stateful
        - Stateless
        - Cap Theorem
    - Vertical scaling describes adding more power to your current machines

Load Balancer
    - https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/
    - /snippets/AWS/sysops.txt
    - https://geekflare.com/open-source-load-balancer/

Design Principles
    - Dry - Don't repeat yourself
        - Maintain the code in one place
    - Kiss - Keep it simple stupid
        - Avoid unnecessary complexity
    - YAGNI - You aint't gonna need It
        - Don't try to think ahead just in case you need it 
    - SOLID - https://www.youtube.com/watch?v=69sfWNzxTMc
        - Single Responsibility Principles
            - A class should have only one reason to change
        - Open/Closed Principle
            - A class should be open for extension, but closed for modification
        - Liscov Substitution Principle
            - You should be able to change an instance using a subType and your code should still work
        - Interface Segragation Principle
            - More interface are better than too little
            - Allow to split the responsibility of a class without LSP violation
        - Dependency Inversion Principle
            - One should depend on abstraction and not concrete instances
The Scale Cube
    - X Axis -  Horizontal Duplication and Cloning of Services and Data
        - This runs behind the load balancer
    - Y Axis - Functional Decomposition and Segmentation - Microservices
        - the_api_composition_pattern.jpg
    - Z Axis - Service and Data partitioning along Customer Bounderies - shards/pods
    - Vertical Scaling - increase computing/hardware resources
    - Horizontal Scaling - spliting the load
        - Stateless - 
            - like the monolith application, split the application behind the load balancer
            - split the microservices behind the load balancer
        - Stateful
            - Database and message broker are stateful
            - CAP Theorem - use for choosing database
                - cap_theorem.jpg
                - cap_theorem_consistency_availability_partition_tolerance.jpg
                - cap_theorem_consitency_or_availability.jpg
                - how_to_choose_database_for_microservices.jpg
                - Database Types
                    - relational_databases.jpg
                    - no_sql_database.jpg
                        - no_sql_document_databases.jpg
                        - no_sql_graph_based_databases.jpg
                        - no-sql_column_based_database.jpg
                        - no_sql_database_key_value.jpg
            - Consistency Level
                - scale_database_in_microservices.jpg
                    - Strict Consistency
                        - means that the client should see changes from database right away
                        - hard to make it scalable, and availability
                    - Eventual Consistency
                        - Client will see changes with longer time latency
                    - Spliting Database Servers 
                        - Managing Data is hard
                        - Microservice Data Management
                            - Database per service its own data
                                - database_per_service_pattern.png
                                - database_per_service_pattern.jpg
                            - Isolating each service's database 
                            - Polyglot Persistence Principle
                            - Duplicated or Partitioned Data Challenge
                            - Microservice Database Management Patterns and Principle
                                - The Database per Service Pattern
                                - The API Composition Pattern
                                - The CQRS Pattern
                                - The Event Sourcing Pattern
                                - The SAGA Pattern
                                    - Choreography
                                    - Orchestration
                                - The Shared Database anti-Pattern

                    - Database Sharding
                        - database_table_sharding_pattern.jpg
                        - database_table_horizontal_vertical_and_functional_data_partitioning.jpg
                        - database_table_horizontal_partitioning.jpg
                        - database_table_vertical_partitioning.jpg
                        - database_table_functional_partitioning.jpg
                        - database_table_sharding_pattern_geo_sharding.jpg
                        - microservice_architecture_database_sharding_pattern.jpg

Design Pattern
    - Database per service Pattern
    - the_event_sourcing_pattern.jpg
    - the_polyglot_persitence.jpg
    - the_saga_pattern.jpg
    - the_shared_database_anti_pattern.jpg
    - the_shared_database_antipattern.jpg

MicroService Data Management Queries
    - Questions: 
        - Should SC microservice query product data and price information to another microservices with sync calls ?
            - Or are there any other way to handle this problem ? 
        - And also what if we have transactional use cases that need to interact several services with rollback features ?
    - Patterns
        - Cross Query Solutions in Microservices
            - API Gateway Patterns
            - Service Aggregator Pattern
        - Materialized View Pattern - https://medium.com/design-microservices-architecture-with-patterns/materialized-view-pattern-f29ea249f8f8
            - materialized_view_pattern.jpg
            - materialized_view_pattern_drawback.jpg
            - Views are generally used when data is to be accessed infrequently and data in table get updated on frequent basis.	
            - On other hand Materialized Views are used when data is to be accessed frequently and data in table not get updated on frequent basis.
            - a table on a disk that contains the result set of a query
            - a query that pulls data from the underlying table
        - CQRS Design Patterns 
            - https://medium.com/design-microservices-architecture-with-patterns/cqrs-design-pattern-in-microservices-architectures-5d41e359768c
            - cqrs_design_pattern.jpg
            - cqrs_design_pattern_1.jpg
            - cqrs_design_pattern_2.jpg
            - cqrs_design_pattern_3.jpg
            - cqrs_design_pattern_4.jpg
            - https://www.redhat.com/architect/illustrated-cqrs
            - CQRS separates reads and writes into different models, using commands to update data, and queries to read data. Single Responsibility Principle
                - Commands should be task-based, rather than data centric. ("Book hotel room", not "set ReservationStatus to Reserved").
                - Queries never modify the database. A query returns a DTO that does not encapsulate any domain knowledge.
                - Commands may be placed on a queue for asynchronous processing, rather than being processed synchronously
            - Pros
                - Separating write activity from ready activities allows you to use the best database technology for the task at hand, for example, a SQL database for writing and a non-SQL database for reading.
                - Independent Scaling
                    - Using separate databases for the read & write models
                    - Assume you have a website which has more reads than write (something like StackOverflow.com). In such a case, you can scale your read models to get better performance.
                    - Read activity tends to be more frequent than writing, thus you can reduce response latency by placing read data sources in strategic geolocations for better performance.
                - Separation of Concern
                    - Separate the read and write logic
            - Cons
                - Supporting the CQRS pattern requires expertise in a variety of database technologies.
                - More cost since you could be using more than one database and more than one type of database
                - Ensuring data consistency requires special consideration in terms of Service Level Agreements (see the CAP theorem).
                - Using a large number of databases means more points of failure, thus companies need to have comprehensive monitoring and fail-safety mechanisms in place to provide adequate operation

        - Event Sourcing Pattern
            - event_sourcing_pattern.jpg
            - event_sourcing_pattern_1.jpg
            - https://dzone.com/articles/microservices-with-cqrs-and-event-sourcing
            - In event-sourcing, any event triggered will be stored in an event store. 
                - There is no update or delete operations on the data, and every event generated will be stored as a record in the database. 
                - If there is a failure in the transaction, the failure event is added as a record in the database. 
                - Each record entry will be an atomic operation.
            - advantages
                - Solves atomicity issues.
                - Maintains history and audit of records.
                - Can be integrated with data analytics as historical records are maintained.
            - limitations
                - Queries on the latest data or a particular piece of data in the event store involve complex handlings.
                - To make the data eventually consistent, this involves asynchronous operations because the data flow integrates with messaging systems.
                - The model that involves inserting and querying the data is the same and might lead to complexity in the model for mapping with the event store.
                - The event store capacity has to be larger in storing all the history of records.
            - cassandra
        - Joining data in the user interface
        - Views between database schemas
        - https://medium.com/@john_freeman/querying-data-across-microservices-8d7a4667668a
        - https://www.oreilly.com/library/view/monolith-to-microservices/9781492047834/ch04.html
        - Eventual Consistency
            - eventual_consistency_principle.jpg
            - eventual_consistency.jpg - https://github.com/mehmetozkaya/Design-Microservices-Architecture-with-Patterns-Principles/tree/main/S14-Microservices%20Data%20Management-Queries/L118-Design%20CQRS%20Event%20Sourcing
        - materialize_cqrs_event_eventual.jpg
        - instagram_system_architechture.jpg

MicroServices Distributed Transactions 
    - https://medium.com/design-microservices-architecture-with-patterns/microservices-distributed-transactions-a71a996e5db8
    - SAGA Pattern - https://medium.com/design-microservices-architecture-with-patterns/saga-pattern-for-microservices-distributed-transactions-7e95d0613345
        - Choreography - https://github.com/mehmetozkaya/Design-Microservices-Architecture-with-Patterns-Principles/tree/main/S15-Microservices%20Distributed%20Transactions/L121-Choreography-Orchestrator%20Saga%20Pattern
            - saga_choreography.jpg - for simple workflow
                - steps needs to be minimal. Increase step adds more complexity
        - Orchestration
            - saga_orchestration.jpg
    -Outbox Pattern
        - https://medium.com/design-microservices-architecture-with-patterns/outbox-pattern-for-microservices-architectures-1b8648dfaa27
Event Driven MicroService Architecture - https://github.com/mehmetozkaya/Design-Microservices-Architecture-with-Patterns-Principles/tree/main/S16-Event-Driven%20Microservices%20Architecture/L124-Design%20Event-Driven%20Microservices
    - event_driven_microservice.jpg
MicroService Distributed Caching - https://medium.com/design-microservices-architecture-with-patterns/microservices-distributed-caching-76828817e41b
    - microservices_distributed_caching.jpg

Microservice Communication
    - Syncrhonous Communication
        - http
        - gRpc / message broker
    - Asynchronous
        - AMQP - message broker
            - https://blog.containerize.com/2021/07/09/top-5-open-source-message-queue-software-in-2021/
            - amqp - nodejs
            - amqplib - nodejs for RabbitMQ
            - Ampersand - js
            - NGINX Amplify
            - AWS Amplify
            - Microsoft Azure Service Bus
            - Amperity
            - Amplitude
            - Amp
            - amqp -  by Go
            - Apache Kafka 
                - Distributed 
                - horizontal scallable
            - Akka
            - Debezium
            - RabbitMQ
            - Celery
            - Nsq
            - Redisson
            - https://stackshare.io/search/q=AMQP
    - APIs/contrats 
        - Each microservice exposes their own API
        - It also publish contracts (WSDL, Swagger, IDL) so that other microservice or developer may know how to interact with your microservice

https://geekflare.com/api-gateway/
- Kong Gateway
- Ambassador
- Apache APISIX
- Tyk
- Ocelot - .net
- Goku - GoLang
- Express Gateway
- Gloo
- KrakenD
- Fusio
- WSO2
- Apigee
- Envoy
- Cloud Endpoints - Google Cloud
- Amazon API Gateway
- Azure
- Google Cloud Endpoints
- Serverless - NPM
- Zuul
- Netty
- Finagle




 https://stackshare.io/service-discovery
 - Consul
 - ZooKeeper - Java
 - Eureka - Springboot
 - etcd 
 - Keepalived
- Serf
- SmartStack
- libraries.io
- SkyDns
- Baker Street
- ODD Platform
- NACOS
- Vyne
- zetcd

Circuit Breaker 
Hystrix
Jrugged

Microservice Authentication and Authorization
- kerberos, OpenID, Oauth 2.0, SMAL
- Okta, Keycloak, shiro 

Deployment
- Jenkins
- Asgard
- Aminator

Environment
Dev, Stage, production

Versioning

https://medium.com/ynap-tech/microservices-solving-a-problem-like-routing-part-1-8e48d789e57