S - Single-responsiblity Principle 
O - Open-closed Principle
L - Liskov Substitution Principle
I - Interface Segregation Principle
D - Dependency Inversion Principle

S - Single-responsiblity Principle 
A class, module, function should have one and only have one job.

O - Open-closed Principle
A class, module, function, objects or entities should be open for extension but closed for modification. 

L - Liskov Substitution Principle
Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.
In short, you should be able to substitute another function or system without breaking the current system.

I - Interface Segregation Principle
A client should never be forced to implement an interface that it doesn’t use, or clients shouldn’t be forced to depend on methods they do not use.
For Example, break your interface into a smaller and usable components. 

D - Dependency Inversion Principle
Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but they should depend on abstractions.
For example, insted of instatiating a class directly into another class, pass the class in the constructor. Or create an interface and implement an interface.



D - Don't
R - Repeat
Y - Yourself

K - Keep
I - It 
S - Simple
S - Stupid

Y - You
A - Ain't
G - Gonna
N - Need
I - It